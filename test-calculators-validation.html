<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Validation des Calculateurs</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .test-result {
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            font-family: monospace;
        }
        .test-pass {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .test-fail {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .progress {
            width: 100%;
            height: 20px;
            background-color: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-bar {
            height: 100%;
            background-color: #4caf50;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <h1>ðŸ§ª Validation des Calculateurs</h1>
    
    <div class="test-container">
        <h2>Progression</h2>
        <div class="progress">
            <div class="progress-bar" id="progress-bar" style="width: 0%"></div>
        </div>
        <div id="progress-text">Initialisation...</div>
    </div>

    <div class="test-container">
        <h2>RÃ©sultats des Tests</h2>
        <div id="test-results"></div>
    </div>

    <!-- Import des modules Ã  tester -->
    <script src="js/calculators/ItemCalculator.js"></script>
    <script src="js/calculators/HourlyCalculator.js"></script>
    <script src="js/calculators/TotalCalculator.js"></script>

    <script>
        let testCount = 0;
        let completedTests = 0;
        const totalTests = 4;

        function randomFloat(min, max) {
            return Math.random() * (max - min) + min;
        }

        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function updateProgress() {
            const percentage = (completedTests / totalTests) * 100;
            document.getElementById('progress-bar').style.width = percentage + '%';
            document.getElementById('progress-text').textContent = 
                `${completedTests}/${totalTests} tests complÃ©tÃ©s (${Math.round(percentage)}%)`;
        }

        function addResult(name, passed, error = null, iterations = null) {
            const resultsContainer = document.getElementById('test-results');
            
            const div = document.createElement('div');
            div.className = `test-result ${passed ? 'test-pass' : 'test-fail'}`;
            
            if (passed) {
                div.innerHTML = `âœ“ ${name}${iterations ? ` (${iterations} itÃ©rations)` : ''}`;
            } else {
                div.innerHTML = `âœ— ${name}: ${error}`;
            }
            
            resultsContainer.appendChild(div);
            completedTests++;
            updateProgress();
        }

        async function runPropertyTest(name, generator, property, iterations = 100) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    try {
                        let failedIteration = -1;
                        let failedData = null;
                        
                        for (let i = 0; i < iterations; i++) {
                            const data = generator();
                            if (!property(data)) {
                                failedIteration = i + 1;
                                failedData = data;
                                break;
                            }
                        }
                        
                        if (failedIteration === -1) {
                            addResult(name, true, null, iterations);
                        } else {
                            addResult(name, false, 
                                `Ã‰chouÃ© Ã  l'itÃ©ration ${failedIteration}: ${JSON.stringify(failedData)}`);
                        }
                        resolve();
                    } catch (error) {
                        addResult(name, false, error.message);
                        resolve();
                    }
                }, 100);
            });
        }

        document.addEventListener('DOMContentLoaded', async () => {
            console.log('ðŸš€ DÃ©marrage des tests des calculateurs...');
            updateProgress();

            // **Feature: invoice-generator, Property 7: Calcul automatique des articles**
            // **Validates: Requirements 3.7**
            await runPropertyTest(
                'Property 7: Calcul automatique des articles',
                () => ({
                    quantity: randomFloat(1, 1000),
                    unitPrice: randomFloat(0.01, 10000),
                    discount: randomFloat(0, 100),
                    vatRate: randomFloat(0, 50)
                }),
                (data) => {
                    const calculatedTotal = ItemCalculator.calculateLineTotal(
                        data.quantity, data.unitPrice, data.discount, data.vatRate
                    );
                    const expectedTotal = (data.quantity * data.unitPrice * (1 - data.discount/100)) * (1 + data.vatRate/100);
                    
                    return Math.abs(calculatedTotal - expectedTotal) < 0.01;
                },
                100
            );

            // **Feature: invoice-generator, Property 9: Calcul automatique des prestations horaires**
            // **Validates: Requirements 4.4**
            await runPropertyTest(
                'Property 9: Calcul automatique des prestations horaires',
                () => ({
                    hours: randomFloat(0.1, 1000),
                    hourlyRate: randomFloat(1, 1000)
                }),
                (data) => {
                    const calculatedTotal = HourlyCalculator.calculateHourlyTotal(data.hours, data.hourlyRate);
                    const expectedTotal = data.hours * data.hourlyRate;
                    
                    return Math.abs(calculatedTotal - expectedTotal) < 0.01;
                },
                100
            );

            // **Feature: invoice-generator, Property 11: Calculs de totaux cohÃ©rents**
            // **Validates: Requirements 5.1, 5.2, 5.3, 5.4**
            await runPropertyTest(
                'Property 11: Calculs de totaux cohÃ©rents',
                () => ({
                    items: Array.from({ length: randomInt(1, 5) }, () => ({
                        quantity: randomFloat(1, 10),
                        unitPrice: randomFloat(1, 100),
                        discount: randomFloat(0, 50),
                        vatRate: randomFloat(0, 25)
                    })),
                    hourlyItems: Array.from({ length: randomInt(1, 3) }, () => ({
                        hours: randomFloat(1, 40),
                        hourlyRate: randomFloat(10, 200)
                    }))
                }),
                (data) => {
                    const totals = TotalCalculator.calculateFinalTotals(data.items, data.hourlyItems);
                    
                    // Calculer manuellement les totaux attendus
                    const itemsSubtotalHT = data.items.reduce((total, item) => {
                        const subtotal = item.quantity * item.unitPrice;
                        const discountAmount = subtotal * (item.discount / 100);
                        return total + (subtotal - discountAmount);
                    }, 0);
                    
                    const hourlySubtotal = data.hourlyItems.reduce((total, item) => {
                        return total + (item.hours * item.hourlyRate);
                    }, 0);
                    
                    const expectedSubtotalHT = itemsSubtotalHT + hourlySubtotal;
                    
                    const expectedTotalVAT = data.items.reduce((total, item) => {
                        const subtotal = item.quantity * item.unitPrice;
                        const discountAmount = subtotal * (item.discount / 100);
                        const subtotalAfterDiscount = subtotal - discountAmount;
                        const vatAmount = subtotalAfterDiscount * (item.vatRate / 100);
                        return total + vatAmount;
                    }, 0);
                    
                    const expectedTotalTTC = expectedSubtotalHT + expectedTotalVAT;
                    
                    // VÃ©rifier la cohÃ©rence des calculs
                    return (
                        Math.abs(totals.subtotalHT - expectedSubtotalHT) < 0.01 &&
                        Math.abs(totals.totalVAT - expectedTotalVAT) < 0.01 &&
                        Math.abs(totals.totalTTC - expectedTotalTTC) < 0.01
                    );
                },
                100
            );

            // **Feature: invoice-generator, Property 10: MÃ©lange d'Ã©lÃ©ments de facturation**
            // **Validates: Requirements 4.5**
            await runPropertyTest(
                'Property 10: MÃ©lange d\'Ã©lÃ©ments de facturation',
                () => ({
                    items: Array.from({ length: randomInt(1, 5) }, () => ({
                        quantity: randomFloat(1, 10),
                        unitPrice: randomFloat(1, 100),
                        discount: randomFloat(0, 50),
                        vatRate: randomFloat(0, 25)
                    })),
                    hourlyItems: Array.from({ length: randomInt(1, 3) }, () => ({
                        hours: randomFloat(1, 40),
                        hourlyRate: randomFloat(10, 200)
                    }))
                }),
                (data) => {
                    // VÃ©rifier que le systÃ¨me peut traiter simultanÃ©ment articles et prestations horaires
                    const totals = TotalCalculator.calculateFinalTotals(data.items, data.hourlyItems);
                    
                    // Le systÃ¨me doit pouvoir calculer des totaux cohÃ©rents avec les deux types d'Ã©lÃ©ments
                    const hasItems = data.items.length > 0;
                    const hasHourlyItems = data.hourlyItems.length > 0;
                    
                    // Si on a les deux types d'Ã©lÃ©ments, le total doit Ãªtre la somme des deux
                    if (hasItems && hasHourlyItems) {
                        const itemsSubtotal = ItemCalculator.calculateSubtotal(data.items);
                        const hourlySubtotal = HourlyCalculator.calculateHourlySubtotal(data.hourlyItems);
                        const expectedSubtotal = itemsSubtotal + hourlySubtotal;
                        
                        return Math.abs(totals.subtotalHT - expectedSubtotal) < 0.01;
                    }
                    
                    return true; // Si on n'a qu'un type, c'est toujours valide
                },
                100
            );

            console.log('âœ… Tests des calculateurs terminÃ©s!');
        });
    </script>
</body>
</html>